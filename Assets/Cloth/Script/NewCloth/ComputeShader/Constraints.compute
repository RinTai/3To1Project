#pragma enable_d3d11_debug_symbols

#pragma kernel UpdateVelocityAndPos;
#pragma kernel Constraint_Distance
#pragma kernel Constraint_Bend
#pragma kernel Constraint_Fixed
#pragma kernel Constraint_Shear
#pragma kernel Constraint_Size

#include "D:\unityProj\My project (1)\Assets\Cloth\Script\NewCloth\ComputeShader\DataHub.hlsl"

float deltaTime;
float alpha;
float4 globalValue[10];
RWStructuredBuffer<PointInfo> _PredictPointBuffer;
RWStructuredBuffer<PointInfo> _PostPointBuffer;
RWStructuredBuffer<DistanceConstraintInfo> _DistanceBuffer;

[numthreads(1, 1, 1)]
void UpdateVelocityAndPos(uint3 id : SV_DispatchThreadID)
{
    PointInfo postPoint = _PostPointBuffer[id.x];
    PointInfo nowPoint = _PredictPointBuffer[id.x];
   
    _PredictPointBuffer[id.x].velocity = (nowPoint.position - postPoint.position) / deltaTime;
  
    _PostPointBuffer[id.x] = nowPoint;
    
    //阻尼的影响 按理来说
    //_PredictPointBuffer[id.x].velocity = (1 - 0.1f) * velocity;
    
    nowPoint.velocity += float3(0.0f, 0.0f, 0.0f) * deltaTime;
   
    nowPoint.position +=  nowPoint.velocity * deltaTime;
    
    _PredictPointBuffer[id.x] = nowPoint;

    if (id.x == 0)
    {
        _PredictPointBuffer[0].position = float3(6.0f, 1.0f, 6.0f);
        _PredictPointBuffer[0].mass = 0.0;
        _PostPointBuffer[0].position = float3(6.0f, 1.0f, 6.0f);
        _PostPointBuffer[0].mass = 0.0;
    }
}

[numthreads(1,1,1)]
void Constraint_Distance(uint3 id : SV_DispatchThreadID)
{
    //得到当前的遍历信息
    DistanceConstraintInfo myInfo = _DistanceBuffer[id.x];

    float lambda = myInfo.lambda;
    
    int v0 = myInfo.vIndex0;
    int v1 = myInfo.vIndex1;
    
    PointInfo p0 = _PostPointBuffer[v0];
    PointInfo p1 = _PostPointBuffer[v1];
    
    float m0 = p0.mass;
    float m1 = p1.mass;
    float mT = m0 + m1;

    float3 pos0 = p0.position;
    float3 pos1 = p1.position;

    float3 dir = pos1 - pos0;
    float dis = distance(pos0, pos1);
    
    if (dis == 0)
        return;
    
    //gradC = (xo-x1) / |x0-x1| 
    float3 gradC_p0 = dir / dis;
    float3 gradC_p1 = -dir / dis;
    float gradC_Length = length(gradC_p0);
        
    float C = abs(dis - myInfo.restDistance);
    float gradC_2 = pow(gradC_Length, 2); //这个实际上是平方
    
    float alpha = 1;
    // 我们采用的是每帧更新 n次约束，因此lambda每次都应该重置为0,也就可以将d_lambda等同于lambda
    // d_lambda = (-C - alpha*lambda) / (gradC * w_T * gradC_T + alpha)
    float d_lambda = (-C ) / (mT * gradC_2 + alpha);
   
    _DistanceBuffer[id.x].lambda += d_lambda;
    //_DistanceBuffer[id.x].lambda += d_lambda;
    //x = x + deltaX where deltaX = gradC * w_T(i) * lambda
    float3 pos_0 = m0  * d_lambda * gradC_p0 ;
    float3 pos_1 = m1  * d_lambda * gradC_p0 ;
    _PredictPointBuffer[v0].position =p0.position + pos_0 ;
    _PredictPointBuffer[v1].position =p1.position + pos_1 ; //对上述求导过程未区分的修正

}

[numthreads(1, 1, 1)]
void Constraint_Bend(uint3 id : SV_DispatchThreadID)
{

}

[numthreads(1, 1, 1)]
void Constraint_Fixed(uint3 id : SV_DispatchThreadID)
{

}

[numthreads(1, 1, 1)]
void Constraint_Shear(uint3 id : SV_DispatchThreadID)
{

}

[numthreads(1, 1, 1)]
void Constraint_Size(uint3 id : SV_DispatchThreadID)
{

}




